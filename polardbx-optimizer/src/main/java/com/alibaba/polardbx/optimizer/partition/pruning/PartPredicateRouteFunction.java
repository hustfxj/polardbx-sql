/*
 * Copyright [2013-2021], Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.alibaba.polardbx.optimizer.partition.pruning;

import com.alibaba.polardbx.common.exception.NotSupportException;
import com.alibaba.polardbx.common.exception.TddlRuntimeException;
import com.alibaba.polardbx.common.exception.code.ErrorCode;
import com.alibaba.polardbx.common.properties.ConnectionParams;
import com.alibaba.polardbx.optimizer.context.ExecutionContext;
import com.alibaba.polardbx.optimizer.core.datatype.DataType;
import com.alibaba.polardbx.optimizer.core.datatype.DataTypeUtil;
import com.alibaba.polardbx.optimizer.partition.PartitionByDefinition;
import com.alibaba.polardbx.optimizer.partition.boundspec.PartitionBoundVal;
import com.alibaba.polardbx.optimizer.partition.boundspec.PartitionBoundValueKind;
import com.alibaba.polardbx.optimizer.partition.PartitionInfo;
import com.alibaba.polardbx.optimizer.partition.common.PartKeyLevel;
import com.alibaba.polardbx.optimizer.partition.common.PartitionStrategy;
import com.alibaba.polardbx.optimizer.partition.datatype.PartitionField;
import com.alibaba.polardbx.optimizer.partition.datatype.function.Monotonicity;
import com.alibaba.polardbx.optimizer.partition.datatype.function.PartitionFunctionBuilder;
import com.alibaba.polardbx.optimizer.partition.datatype.function.PartitionIntFunction;
import com.alibaba.polardbx.optimizer.partition.exception.InvalidTypeConversionException;
import com.alibaba.polardbx.optimizer.partition.exception.SubQueryDynamicValueNotReadyException;
import com.alibaba.polardbx.optimizer.utils.ExprContextProvider;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.sql.SqlCall;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql.SqlOperator;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;

/**
 * Route one simple interval(maybe a multi-column range)
 * for the special key level of partitioned table
 * <p>
 * <pre>
 *
 * e.g
 *     route the interval (partKey) <= (?+?) for range partitions
 * e.g
 *     route the interval (partKey1, partKey2, partKey3) <= (?+?, ?, ?)
 *     for range columns partitions
 * e.g
 *     route the interval (partKey1, partKey2, partKey3) = (?, ?, ?)
 *     for Hash key partitions
 *
 * </pre>
 *
 * @author chenghui.lch
 */
public class PartPredicateRouteFunction extends PartRouteFunction {

    protected ExprContextProvider contextHolder;

    /**
     * The partition strategy
     */
    protected PartitionStrategy strategy;

    /**
     * The search expr from predicate
     * <pre>
     * e.g Assume (p1,p2,p3) are the whole part columns for range columns/list columns,
     *     the predicate expr list may be just a part column prefix, such as
     *     predicate1: p1 = const1*const4
     *     predicate2: p2 < const2+const3 ,
     *     that means that this PartPredicateRouteFunction will performance the interval ranges of
     *     "p1=const1*const4 and  p2<const2+const3" .
     *     , then the SearchExprInfo will be "(p1,p2,p3) < (const1*const4, const2+const3, min)"
     * </pre>
     */
    protected SearchExprInfo searchExprInfo = null;

    /**
     * The flag that label if the part routing need do interval mapping from query space to search space
     */
    protected boolean needMapInterval = false;

    /**
     * The flag that label if need eval the part func value for the first part key by using the expr value of predicate
     */
    protected boolean needEvalPartFunc = false;

    /**
     * label if the part int func of the first part key is a not-monotonic func
     */
    protected boolean isNonMonotonic = false;

    /**
     * The part func expr of part key 0, just for range/list/hash
     */
    protected SqlOperator partFuncOperator = null;

    /**
     * the return data type of the partFuncOperator
     */
    protected DataType partExprReturnType = null;

    /**
     * The router info of part func expr of all part keys
     */
    protected PartFuncExprRouterInfo[] partFuncRouterInfoArr;

    public PartPredicateRouteFunction(PartitionInfo partInfo,
                                      SqlOperator partFuncOperator,
                                      PartKeyLevel keyLevel,
                                      SearchExprInfo searchExprInfo,
                                      ExprContextProvider contextHolder) {
        this.partInfo = partInfo;
        this.contextHolder = contextHolder;
        this.matchLevel = keyLevel;
        this.searchExprInfo = searchExprInfo;
        this.partFuncOperator = partFuncOperator;
        this.cmpKind = searchExprInfo.getCmpKind();
        initRouteFunction();
    }

    protected void initRouteFunction() {
        // Get the partCount and subPartCount of subPartition template
//        this.partCount = partInfo.getPartitionBy().getPartitions().size();
//        this.subPartCount = -1;
//        if (this.partInfo.getPartitionBy().getSubPartitionBy() != null) {
//            this.subPartCount = this.partInfo.getPartitionBy().getPartitions().get(0).getSubPartitions().size();
//        }

        // Router should be cached
        PartitionByDefinition partByDef = null;
        if (matchLevel == PartKeyLevel.PARTITION_KEY) {
            this.strategy = partInfo.getPartitionBy().getStrategy();
            partByDef = partInfo.getPartitionBy();
        } else if (matchLevel == PartKeyLevel.SUBPARTITION_KEY) {
            this.strategy = partInfo.getPartitionBy().getSubPartitionBy().getStrategy();
            partByDef = partInfo.getPartitionBy().getSubPartitionBy();
        }

        if (this.strategy != PartitionStrategy.CO_HASH) {
            SqlNode partExpr = partByDef.getPartitionExprList().get(0);
            if (PartitionFunctionBuilder.checkStrategySupportPartFunc(this.strategy)
                || this.strategy == PartitionStrategy.DIRECT_HASH) {
                if (partExpr instanceof SqlCall) {
                    /**
                     * The part columns is wrapped with func, such year(partCol)...
                     * , so need do interval mapping
                     */
                    this.needEvalPartFunc = true;
                    RelDataType partExprDt = partByDef.getPartitionExprTypeList().get(0);
                    this.partExprReturnType = DataTypeUtil.calciteToDrdsType(partExprDt);
                    Monotonicity monotonicity = partByDef.getPartIntFuncMonotonicity();
                    this.isNonMonotonic = monotonicity == Monotonicity.NON_MONOTONIC;
                    if (this.cmpKind != ComparisonKind.EQUAL && this.cmpKind != ComparisonKind.NOT_EQUAL) {
                        if (this.strategy == PartitionStrategy.RANGE || this.strategy == PartitionStrategy.LIST) {
                            this.needMapInterval = true;
                        }
                    }
                }

                PartFuncExprRouterInfo tmpPartFuncExprRouterInfo = new PartFuncExprRouterInfo();
                tmpPartFuncExprRouterInfo.setPartKeyIndex(0);
                if (this.needEvalPartFunc) {
                    PartitionIntFunction[] partFuncArr = partByDef.getPartFuncArr();
                    tmpPartFuncExprRouterInfo.setPartFunc(partFuncArr[0]);
                    tmpPartFuncExprRouterInfo.setNeedEvalPartFunc(this.needEvalPartFunc);
                    tmpPartFuncExprRouterInfo.setPartExprReturnType(this.partExprReturnType);
                    tmpPartFuncExprRouterInfo.setPartFuncOperator(this.partFuncOperator);

                } else {
                    tmpPartFuncExprRouterInfo.setPartFunc(null);
                    tmpPartFuncExprRouterInfo.setNeedEvalPartFunc(false);
                    tmpPartFuncExprRouterInfo.setPartExprReturnType(null);
                    tmpPartFuncExprRouterInfo.setPartFuncOperator(null);
                }
                PartFuncExprRouterInfo[] tmpPartFuncRouterInfoArr =
                    new PartFuncExprRouterInfo[partByDef.getPartitionExprList().size()];
                tmpPartFuncRouterInfoArr[0] = tmpPartFuncExprRouterInfo;
                this.partFuncRouterInfoArr = tmpPartFuncRouterInfoArr;
            } else {
                List<String> partColList = partByDef.getPartitionColumnNameList();
                PartFuncExprRouterInfo[] tmpPartFuncRouterInfoArr = new PartFuncExprRouterInfo[partColList.size()];
                for (int i = 0; i < tmpPartFuncRouterInfoArr.length; i++) {
                    PartFuncExprRouterInfo tmpPartFuncExprRouterInfo = new PartFuncExprRouterInfo();
                    tmpPartFuncExprRouterInfo.setPartKeyIndex(i);
                    tmpPartFuncExprRouterInfo.setPartFunc(null);
                    tmpPartFuncExprRouterInfo.setNeedEvalPartFunc(false);
                    tmpPartFuncExprRouterInfo.setPartExprReturnType(null);
                    tmpPartFuncExprRouterInfo.setPartFuncOperator(null);
                    tmpPartFuncRouterInfoArr[i] = tmpPartFuncExprRouterInfo;
                }
                this.partFuncRouterInfoArr = tmpPartFuncRouterInfoArr;
            }
        } else {
            PartitionIntFunction[] partFuncArr = partByDef.getPartFuncArr();
            PartFuncExprRouterInfo[] tmpPartFuncRouterInfoArr = new PartFuncExprRouterInfo[partFuncArr.length];
            for (int i = 0; i < partFuncArr.length; i++) {
                PartitionIntFunction partFunc = partFuncArr[i];
                PartFuncExprRouterInfo tmpPartFuncExprRouterInfo = new PartFuncExprRouterInfo();
                tmpPartFuncExprRouterInfo.setPartKeyIndex(i);
                tmpPartFuncExprRouterInfo.setPartFunc(partFunc);
                if (partFunc != null) {
                    /**
                     * The part columns is wrapped with func, such year(partCol)...
                     * , so need do interval mapping
                     */
                    tmpPartFuncExprRouterInfo.setNeedEvalPartFunc(true);
                    tmpPartFuncExprRouterInfo.setPartExprReturnType(partFunc.getReturnType());
                    tmpPartFuncExprRouterInfo.setPartFuncOperator(partFunc.getSqlOperator());

                } else {
                    tmpPartFuncExprRouterInfo.setNeedEvalPartFunc(false);
                    tmpPartFuncExprRouterInfo.setPartExprReturnType(null);
                    tmpPartFuncExprRouterInfo.setPartFuncOperator(null);
                }
                tmpPartFuncRouterInfoArr[i] = tmpPartFuncExprRouterInfo;
            }
            this.partFuncRouterInfoArr = tmpPartFuncRouterInfoArr;
            this.isNonMonotonic = true;
            this.needMapInterval = false;

            PartFuncExprRouterInfo firstPartFuncInfo = tmpPartFuncRouterInfoArr[0];
            this.needEvalPartFunc = firstPartFuncInfo.isNeedEvalPartFunc();
            this.partFuncOperator = firstPartFuncInfo.getPartFuncOperator();
            this.partExprReturnType = firstPartFuncInfo.getPartExprReturnType();
        }
    }

    protected SearchDatumInfo buildSearchDatumInfoForPredData(ExecutionContext context,
                                                              PartPruneStepPruningContext pruningCtx,
                                                              ComparisonKind[] cmdKindOutput) {

        PartClauseExprExec[] predExprExecArr = this.searchExprInfo.getExprExecArr();
        ComparisonKind cmpKind = this.searchExprInfo.getCmpKind();
        int partColNum = predExprExecArr.length;
        PartitionBoundVal[] searchValArr = new PartitionBoundVal[partColNum];
        PartitionStrategy strategy = this.strategy;

        if (strategy != PartitionStrategy.CO_HASH) {
            if (partColNum > 1) {
                SearchExprEvalResult exprEvalResult =
                    PartitionPrunerUtils.evalExprValsAndBuildOneDatum(context, pruningCtx, this.searchExprInfo);
                cmdKindOutput[0] = exprEvalResult.getComparisonKind();
                SearchDatumInfo searchDatumInfo = exprEvalResult.getSearchDatumInfo();
                return searchDatumInfo;
            } else {
                PartClauseExprExec exprExec = predExprExecArr[0];
                PartFuncExprRouterInfo partFuncRouterInfo = partFuncRouterInfoArr[0];
                PartitionBoundVal searchVal =
                    evalExprAndThenEvalPartFunc(context, pruningCtx, cmpKind, exprExec, partFuncRouterInfo,
                        cmdKindOutput);
                searchValArr[0] = searchVal;
                SearchDatumInfo searchDatumInfo = new SearchDatumInfo(searchValArr);
                return searchDatumInfo;
            }
        } else {
            for (int i = 0; i < partColNum; i++) {
                PartClauseExprExec exprExec = predExprExecArr[i];
                PartFuncExprRouterInfo partFuncRouterInfo = partFuncRouterInfoArr[i];
                PartitionBoundVal searchVal =
                    evalExprAndThenEvalPartFunc(context, pruningCtx, cmpKind, exprExec, partFuncRouterInfo,
                        cmdKindOutput);
                searchValArr[i] = searchVal;
            }
            SearchDatumInfo searchDatumInfo = new SearchDatumInfo(searchValArr);
            return searchDatumInfo;
        }

//        if (partColNum > 1) {
//            SearchExprEvalResult exprEvalResult =
//                PartitionPrunerUtils.evalExprValsAndBuildOneDatum(context, pruningCtx, this.searchExprInfo);
//            cmdKindOutput[0] = exprEvalResult.getComparisonKind();
//            SearchDatumInfo searchDatumInfo = exprEvalResult.getSearchDatumInfo();
//            return searchDatumInfo;
//        } else {
//            PartClauseExprExec exprExec = predExprExecArr[0];
//            PartitionBoundVal searchVal =
//                evalExprAndThenEvalPartFunc(context, pruningCtx, cmpKind, exprExec, cmdKindOutput);
//            searchValArr[0] = searchVal;
//            SearchDatumInfo searchDatumInfo = new SearchDatumInfo(searchValArr);
//            return searchDatumInfo;
//        }
    }

    /**
     * Eval the const expr of part predicate and then eval the part func expr
     * by using the eval result of the const expr above
     */
    @NotNull
    private PartitionBoundVal evalExprAndThenEvalPartFunc(ExecutionContext context,
                                                          PartPruneStepPruningContext pruningCtx,
                                                          ComparisonKind cmpKind,
                                                          PartClauseExprExec exprExec,
                                                          PartFuncExprRouterInfo partFuncRouterInfo,
                                                          ComparisonKind[] cmdKindOutput) {
        boolean isAlwaysNull = exprExec.isAlwaysNullValue();
        boolean[] epInfo = PartFuncMonotonicityUtil.buildIntervalEndPointInfo(cmpKind);
        PartitionBoundValueKind valKind = exprExec.getValueKind();

        // Compute the const expr val for part predicate
        PartitionField exprValPartField = exprExec.evalPredExprVal(context, pruningCtx, epInfo);

        PartitionField newPartField = null;
        if (valKind == PartitionBoundValueKind.DATUM_NORMAL_VALUE) {
            // Do the interval mapping from predicate query space to partition search space
            // and put the mapping result into the cmdKindOutput.
            newPartField =
                doIntervalMapping(exprExec, partFuncRouterInfo, context, exprValPartField, cmdKindOutput, epInfo);
        }

        // Build the PartitionBoundVal
        PartitionBoundVal searchVal =
            PartitionBoundVal.createPartitionBoundVal(newPartField, valKind, isAlwaysNull);

        return searchVal;
    }

    /**
     *
     */
    private PartitionField doIntervalMapping(PartClauseExprExec exprExec,
                                             PartFuncExprRouterInfo partFuncRouterInfo,
                                             ExecutionContext context,
                                             PartitionField exprValPartField,
                                             ComparisonKind[] cmdKindOutput,
                                             boolean[] endpoints) {

        boolean needEvalPartFunc = partFuncRouterInfo.isNeedEvalPartFunc();
        DataType partExprReturnType = partFuncRouterInfo.getPartExprReturnType();
        ComparisonKind finalCmpKind = PartFuncMonotonicityUtil.buildComparisonKind(endpoints);
        PartitionField newPartField;
        if (needEvalPartFunc) {
            PartitionIntFunction partIntFunc = exprExec.getPartIntFunc();

            PartitionField partFuncVal = PartitionPrunerUtils
                .evalPartFuncVal(exprValPartField, partIntFunc, getStrategy(), context, endpoints,
                    PartFieldAccessType.QUERY_PRUNING);

            if (this.needMapInterval && !isNonMonotonic && endpoints != null) {
                /**
                 * here endpoints must be NOT null,
                 * if endpoints is null, that means finalCmpKind must be an equal expr
                 */

                /**
                 *
                 * <pre>
                 *     endpoints[0] means cmpDirection:
                 *      if endpoints[0]=false,
                 *          that means constExpr is NOT the leftEndPoint of a range, such as partCol < const or partCol <= const;
                 *     if endpoints[0]=true,
                 *          that means constExpr is the leftEndPoint of a range, such as constExpr < partCol or constExpr <= partCol;
                 *
                 *     endpoints[1] means if the endpoint is included:
                 *      if endpoints[1]=false,
                 *          that means constExpr should NOT be included, such as partCol < const or  partCol > const;
                 *     if endpoints[1]=true,
                 *          that means constExpr should be included, such as partCol <= const or  partCol >= const;
                 * </pre>
                 *
                 */
                // leftEndPoint[0] = false => part </<= const
                // leftEndPoint[1] = true => part >/>= const
                /**
                 * <pre>
                 * leftEndPoint=true  <=>  const < col or const <= col, so const is the left end point,
                 * leftEndPoint=false <=>  col < const or col <= const, so const is NOT the left end point,
                 *
                 * includeEndPoint=true <=> const <= col or col <= const
                 * includeEndPoint=false <=> const < col or col < const
                 * </pre>
                 *
                 */
                boolean leftEndPoint = endpoints[0];
                boolean includeEndPoint = endpoints[1];
                if (leftEndPoint && !includeEndPoint) {
                    /**
                     * Handle the case :  const < col, if the monotonicity of part func is increase
                     */
                    long longVal = partFuncVal.longValue();
                    endpoints[1] = true;
                    newPartField =
                        PartitionPrunerUtils
                            .buildPartField(longVal + 1, partExprReturnType, partExprReturnType, null, context,
                                PartFieldAccessType.QUERY_PRUNING);
                } else {
                    newPartField = partFuncVal;
                }
                finalCmpKind = PartFuncMonotonicityUtil.buildComparisonKind(endpoints);

            } else {

                newPartField = partFuncVal;

                if (isNonMonotonic) {
                    /**
                     * For the partInfFunc of Monotonicity.NON_MONOTONIC, 
                     * if it is a range query, then do full scan directly
                     */
                    // Use ComparisonKind.NOT_EQUAL to do full scan
                    if (finalCmpKind != ComparisonKind.EQUAL) {
                        finalCmpKind = ComparisonKind.NOT_EQUAL;
                    }
                }
            }
        } else {
            newPartField = exprValPartField;
        }
        cmdKindOutput[0] = finalCmpKind;
        return newPartField;
    }

    @Override
    public PartPrunedResult routePartitions(ExecutionContext context, PartPruneStepPruningContext pruningCtx,
                                            List<Integer> parentPartPosiSet) {
        return routeAndBuildPartBitSet(context, pruningCtx, parentPartPosiSet);
    }

    protected PartPrunedResult routeAndBuildPartBitSet(ExecutionContext context, PartPruneStepPruningContext pruningCtx,
                                                       List<Integer> parentPartPosiSet) {

        ComparisonKind[] cmpKindOutput = new ComparisonKind[1];
        SearchDatumInfo finalVal = null;
        BitSet pruneBitSet = null;

        Integer parentPartPosi =
            parentPartPosiSet == null || parentPartPosiSet.isEmpty() ? null : parentPartPosiSet.get(0);
        PartitionRouter router = getRouterByPartInfo(this.matchLevel, parentPartPosi, this.partInfo);
        try {
            // Compute the const expr val for part predicate
            finalVal = buildSearchDatumInfoForPredData(context, pruningCtx, cmpKindOutput);
        } catch (Throwable ex) {
            if (ex instanceof InvalidTypeConversionException) {
                /**
                 *  when it is failed to compute its SearchDatumInfo because of 
                 *  unsupported type conversion exception,
                 *  the SearchExprInfo should be ignore and
                 *  so generate a full scan bitset
                 */

                pruneBitSet = PartitionPrunerUtils.buildFullScanPartitionsBitSetByPartRouter(router);
                return PartPrunedResult.buildPartPrunedResult(partInfo, pruneBitSet, this.matchLevel, parentPartPosi,
                    false);
            } else if (ex instanceof SubQueryDynamicValueNotReadyException) {
                /**
                 *  when it is failed to compute its SearchDatumInfo because of
                 *  the not-ready subquery-dyanamic value,
                 *  the SearchExprInfo should be ignore and
                 *  so generate a full scan bitset
                 */
                pruneBitSet = PartitionPrunerUtils.buildFullScanPartitionsBitSetByPartRouter(router);
                return PartPrunedResult.buildPartPrunedResult(partInfo, pruneBitSet, this.matchLevel, parentPartPosi,
                    false);
            } else {
                throw ex;
            }
        }

        // find the target partition position set
        PartitionRouter.RouterResult result = router.routePartitions(context, cmpKindOutput[0], finalVal);

        // Save the pruned result into bitset
        BitSet allPartBitSet = PartitionPrunerUtils.buildEmptyPartitionsBitSetByPartRouter(router);
        if (result.strategy != PartitionStrategy.LIST && result.strategy != PartitionStrategy.LIST_COLUMNS) {
            PartitionPrunerUtils
                .setPartBitSetByStartEnd(allPartBitSet, result.partStartPosi, result.pasrEndPosi, true);
        } else {
            PartitionPrunerUtils
                .setPartBitSetForPartList(allPartBitSet, result.partPosiSet, true);
        }
        return PartPrunedResult.buildPartPrunedResult(partInfo, allPartBitSet, this.matchLevel, parentPartPosi, false);
    }

    public ExprContextProvider getContextHolder() {
        return contextHolder;
    }

    public boolean isNeedMapInterval() {
        return needMapInterval;
    }

    public SearchExprInfo getSearchExprInfo() {
        return searchExprInfo;
    }

    public SqlOperator getPartFuncOperator() {
        return partFuncOperator;
    }

    @Override
    public PartitionStrategy getStrategy() {
        return strategy;
    }

    @Override
    public PartPredicateRouteFunction copy() {
        PartPredicateRouteFunction routeFunction =
            new PartPredicateRouteFunction(this.partInfo, this.partFuncOperator, this.matchLevel,
                this.searchExprInfo.copy(), this.contextHolder);
        return routeFunction;
    }
}
